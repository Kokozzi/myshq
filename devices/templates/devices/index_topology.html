{% extends "devices/index.html" %}
{% load staticfiles %}

{% block css_topology %}
<link href="{% static 'css/netjsongraph.css' %}" rel="stylesheet">
<link href="{% static 'css/netjsongraph-theme.css' %}" rel="stylesheet">
<link href="{% static 'css/d3test.css' %}" rel="stylesheet">
{% endblock css_topology %}

{% block active_topology %}<li class="active">{% endblock active_topology %}

{% block topology %}
<div class="wrapper wrapper-content animated fadeInRight">  
            <script src="{% static 'js/d3.min.js' %}"></script>
            <script src="{% static 'js/jquery-2.1.1.js' %}"></script>
            <div id="graphContainer" class="graphContainer">
            <script>
            $(function(){
                var data = {
                    "nodes": [
                        {% autoescape off %}
                        {% for device in node %}
                        { {{ device }} },
                        {% endfor %}
                        
                    ],
                    "links": [   
                        {% for l in link %}  
                        { {{ l }} },
                        {% endfor %}
                        {% endautoescape %}
                    ]
                };          

                // used to store the number of links between two nodes. 
                // mLinkNum[data.links[i].source + "," + data.links[i].target] = data.links[i].linkindex;
                var mLinkNum = {};

                // sort links first
                sortLinks();                                

                // set up linkIndex and linkNumer, because it may possible multiple links share the same source and target node
                setLinkIndexAndNum();

                var w = document.getElementById('page-wrapper').offsetWidth - 40,
                    h = document.documentElement.clientHeight/1.6;

                var force = d3.layout.force()
                              .size([w, h])
                              .linkDistance(250)
                              .charge(-1200)
                              .on("tick", tick);

                var drag = force.drag()
                                .on("dragstart", dragstart);
                              
                    force
                        .nodes(d3.values(data.nodes))
                        .links(data.links)
                        .start();

                var svg = d3.select(".graphContainer").append("svg:svg")
                            .attr("width", w)
                            .attr("height", h);

                var path = svg.append("svg:g")
                              .selectAll("path")
                              .data(force.links())
                              .enter().append("svg:path")
                              .attr("class", "link")
                              .on("click", onClickLink);

                var circle = svg.selectAll(".circle")
                                .data(force.nodes())
                                .enter().append("g")
                                .attr("class", "circle")
                                .on("click", OnClickNode)
                                .call(drag);
                    circle.append("svg:image")
                                .attr("xlink:href", function(d) { return d.icon; })
                                .attr("x", "-25px")
                                .attr("y", "-25px")
                                .attr("width", "75px")
                                .attr("height", "75px");

                var text = svg.append("svg:g")                                
                              .selectAll("g")
                              .data(force.nodes())
                              .enter().append("svg:g");

                // A copy of the text with a thick white stroke for legibility.
                text.append("svg:text")
                    .attr("x", 50)
                    .attr("y", ".51em")
                    .attr("class", "shadow")
                    .style("font-size", 12)
                    .style("font-family", "sans-serif")
                    .text(function(d) { return d.name; });  

                text.append("svg:text")
                    .attr("x", 50)
                    .attr("y", ".51em")
                    .style("font-size", 12)
                    .style("font-family", "sans-serif")
                    .text(function(d) { return d.name; });

                // Overlay panel with node information (top-right corner)
                var overlay = d3.select(".graphContainer").append("div")
                                .attr("class", "njg-overlay");

                var closeOverlay = overlay.append("a")
                                    .attr("class", "njg-close")
                                    .on("click", function() {
                                        removeOpenClass();
                                        overlay.classed("njg-hidden", true);
                                    });

                var overlayInner = overlay.append("div")
                                   .attr("class", "njg-inner");

                // Use elliptical arc path segments to doubly-encode directionality.
                function tick() {
                    path.attr("d", function(d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy);
                        // get the total link numbers between source and target node
                        var lTotalLinkNum = mLinkNum[d.source.id + "," + d.target.id] || mLinkNum[d.target.id + "," + d.source.id];
                        if(lTotalLinkNum > 1)
                        {
                            // if there are multiple links between these two nodes, we need generate different dr for each path
                            dr = dr/(1 + (1/lTotalLinkNum) * (d.linkindex - 1));
                            // generate svg path
                            return "M" + d.source.x + "," + d.source.y + 
                                "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + 
                                "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y; 
                        }       
                        // generate svg path
                        return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;   
                    });

                    // Add tooltip to the connection path
                    path.append("svg:title")
                        .text(function(d, i) { return d.name; });

                    circle.attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")"; });
                          //.classed("fixed", d.fixed = true);

                    text.attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });
                } 

                function dragstart(d) {
                  d3.select(this).classed("fixed", d.fixed = true);
                }

                function OnClickNode(d) {
                    var overlay = d3.select(".njg-overlay"),
                        overlayInner = d3.select(".njg-overlay > .njg-inner"),
                        //html = "<p><b>Название</b>: " + d.name + "</p>";
                        html = "<h4>" + d.name + "</h4>";
                    //if(d.IpAddress) { html += "<p><b>IP Address</b>: " + d.IpAddress + "</p>"; }
                    html+='<table class="table table-striped">';
                    html+='<tbody>';
                    html+='<tr>';
                    html+='<th scope="row">Device Type</th>';
                    html+='<td>' + d.device_type + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">Protocol ver.</th>';
                    html+='<td>' + d.protocol_vers + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">Vendor</th>';
                    html+='<td>' + d.company + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">IP Address</th>';
                    html+='<td>' + d.IpAddress + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">IP Connection</th>';
                    html+='<td>' + d.ip_conn + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">Port</th>';
                    html+='<td>' + d.port + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">HW Address</th>';
                    html+='<td>' + d.hw_address + '</td>';
                    html+='</tr>';
                    html+='<tr>';
                    html+='<th scope="row">Serial</th>';
                    html+='<td>' + d.serial + '</td>';
                    html+='</tr>';
                    html+='</tbody>';
                    html+='</table>';
                    overlayInner.html(html);
                    overlay.classed("njg-hidden", false);
                    overlay.style("display", "block");
                    // set "open" class to current node
                    removeOpenClass();
                    d3.select(this).classed("njg-open", true);
                } 

                function onClickLink(d) {
                    var overlay = d3.select(".njg-overlay"),
                        overlayInner = d3.select(".njg-overlay > .njg-inner"),
                        html = "<p><b>Source</b>: " + (d.source.name || d.source.id) + "</p>";
                    html += "<p><b>Target</b>: " + (d.target.name || d.target.id) + "</p>";
                    html += "<p><b>Route ID</b>: " + d.name + "</p>";
                    overlayInner.html(html);
                    overlay.classed("njg-hidden", false);
                    overlay.style("display", "block");
                    // set "open" class to current link
                    removeOpenClass();
                    d3.select(this).classed("njg-open", true);
                }

                removeOpenClass = function () {
                    d3.selectAll("svg .njg-open").classed("njg-open", false);
                };

                // sort the links by source, then target
                function sortLinks()
                {                               
                    data.links.sort(function(a,b) {
                        if (a.source > b.source) 
                        {
                            return 1;
                        }
                        else if (a.source < b.source) 
                        {
                            return -1;
                        }
                        else 
                        {
                            if (a.target > b.target) 
                            {
                                return 1;
                            }
                            if (a.target < b.target) 
                            {
                                return -1;
                            }
                            else 
                            {
                                return 0;
                            }
                        }
                    });
                }

                //any links with duplicate source and target get an incremented 'linknum'
                //data.links.length
                function setLinkIndexAndNum()
                {                               
                    for (var i = 0; i < data.links.length; i++) 
                    {
                        if (i != 0 &&
                            data.links[i].source == data.links[i-1].source &&
                            data.links[i].target == data.links[i-1].target) 
                        {
                            data.links[i].linkindex = data.links[i-1].linkindex + 1;
                        }
                        else 
                        {
                            data.links[i].linkindex = 1;
                        }
                        // save the total number of links between two nodes
                        if(mLinkNum[data.links[i].target + "," + data.links[i].source] !== undefined)
                        {
                            mLinkNum[data.links[i].target + "," + data.links[i].source] = data.links[i].linkindex;
                        }
                        else
                        {
                            mLinkNum[data.links[i].source + "," + data.links[i].target] = data.links[i].linkindex;
                        }
                    }
                }   
            });         
            </script>                    
            </div>    

            <div class="row">
                <div class="col-lg-12">
                    <div class="panel panel-default">
                        <table class="table">
                            <tbody>
                            <tr>
                                {% if object.icon == "Cisco" %}
                                    <td style="padding: 27px;" width=5% align="center" valign="middle" ><img src="{% static 'img/cisco.png' %}"></td>
                                {% elif object.icon == "Juniper" %}
                                    <td style="padding: 27px;" width=5% align="center" valign="middle" ><img src="{% static 'img/junos.png' %}"></td>
                                {% else %}
                                    <td style="padding: 27px;" width=5% align="center" valign="middle" ></td>
                                {% endif %}
                                <td><h3>{{ object.hostname }}</h3>{{ object.location }}<br>{{ object.ip }}</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
</div>
{% endblock topology %}